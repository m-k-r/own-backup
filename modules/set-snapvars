#!/bin/bash

# 3 Snapshots are needed:
# snap_new_source - this is always the newest snapshot
# snap_common_source - this is the last common snapshot on source and target
# snap_old_target - this is the newest snapshot on target. It is only needed with zfs for rollback

if	[ "${mode_snapshot}" == "zfs" ] || [ "${mode_snapshot}" == "btrfs" ]
	then	# Check if sourcesnaps exist. Without it all zfs and btrfs send will fail
			if	[ ! -n "${snap_shots_source_current}" ]
				then	exit 88
			fi
fi

# if snapshots exist on target the newest common snapshot between source and target, snap_common_source, needs to be be determined
if	[ "${snap_number_target_current}" -ge 1 ] && [ "${snap_number_source_current}" -ge 2 ]
	then

		probe_snap_shots_source=${snap_shots_source_current}
		bb=${snap_number_source_current}

		while [ "${bb}" -ge 1 ]
		do	# For God's sake, do not ever quote ${probe_snap_shots_source} again. NEVER!!!
			probe_snap_shot_source=$(echo ${probe_snap_shots_source} | awk '{print $(NF)}')
			probe_snap_name_source=${probe_snap_shot_source: -$snap_string_offset}
			probe=$(echo "${snap_shots_target_current}" | grep "${probe_snap_name_source}")

			if [ -n "${probe}" ]
				then	snap_common_source=${probe_snap_shot_source}
						break
				else	probe_snap_shots_source=$(echo ${probe_snap_shots_source} | rev | cut -d " " -f 2- | rev)
						bb=$((${bb} - 1))
			fi
		done

		if	[ "${snap_number_source_current}" -eq "${bb}" ]
			then	# if this is true the common snapshot is the newest on source and send would fail
					snap_common_source=newest
			else	snapvars_loops=passed
		fi
fi

# if no snaphots on target are found snap_common_source is "unset". If no common snapshot is found the script exits with an error
if	[ ! -n "${snap_common_source}" ]
	then	if	[ "${snapvars_loops}" == "passed" ]
				then	exit 89
				else	snap_common_source=unset
			fi
fi

echo "${snap_common_source} ${bb}"