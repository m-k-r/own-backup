#!/bin/bash
#
# -----------------------------------------------------------------------------
#
# Author:	Marcel Keller (m-k-r)
# Usage:	uses config files to backup btrfs, zfs, file, directory, mysql and kvm to other disk or server
# License:	GPLv3 http://www.gnu.org/licenses/gpl-3.0
#
# ----------------------------- Global Variables ------------------------------

version=1.0
usage="usage: own-backup [parameter]

 -c	name of the config file without '.conf' at the end
 -d	debug: check or show a dump, or create a dump of every module
 -e	overrides the target for snapshot in config
 -f	overrides the frequency in config for source and target
 -m	copies multiple snapshots instead of the last. valid: all or a restriction like 'daily' for all snapshots containing daily
 -n	overrides limit for snapshots to keep. has to be integer and source and target are separated by ':' like '5:5'
 -o	output: commands, datasets, snapshots, snapvars, full
 -r	rollback. Source and target are swapped. No new snapshots are created
 -s	overrides 'snapshotformat (name)' in config
 -t	overrides the date
 -v	show version of this script
 -h	this page"
dir_root=/usr/local/own-backup
dir_modules=${dir_root}/modules
mode_supported="directory file kvm mysql pgsql rsync"
fs_supported="btrfs zfs file"

# --------------------------------- Parameter ----------------------------------

if [ "$#" == "0" ]
	then	echo "${usage}" && exit 0
fi

while getopts ":c:d:e:f:m:n:o:rs:t:vh" opt; do
	case ${opt} in
		c)	config=$OPTARG
			;;
		d)	debug=$OPTARG
			if [ ! ${debug} == "create" ]; then
			${dir_modules}/do-debug "$@"
			exit 0; fi
			;;
		e)	dir_snap_target_override=$OPTARG
			;;
		f)	snap_list_frequency_override=$OPTARG
			;;
		m)	snap_multi=$OPTARG
			;;
		n)	snap_limit_override=$OPTARG
			;;
		o)	output=$OPTARG
			;;
		r)	snap_rollback=set
			;;
		s)	snap_name=$OPTARG
			;;
		t)	snap_date_override=$OPTARG
			;;
		v)	echo "${version}"
			exit 0
			;;
		h)	echo "${usage}"
			exit 0
			;;
		?)	echo "Invalid option: -$OPTARG" >&2 && exit 1
			;;
	esac
done

######################### CONFIG #########################

dir_conf=/etc/own-backup
conf=${dir_conf}/${config}.conf
probe=$(find ${conf} 2>&1)

# check if config file exists
if [ ! "${probe}" == "${conf}" ]
	then	echo "the config-file does not exist" && exit 1
fi

if [ -n "${snap_limit_override}" ]
	then	snap_limit_source=$(echo "${snap_limit_override}" | cut -d ":" -f 1)
		snap_limit_target=$(echo "${snap_limit_override}" | cut -d ":" -f 2)
fi

export debug snap_multi dir_snap_target_override snap_rollback snap_name_override snap_list_frequency_override snap_limit_source snap_limit_target dir_modules mode_supported fs_supported

##### define functions #####

# if exit returns a non-zero value, show the apropriate error message and exit
function check-exit {
	exit_code=${?}
	if [ ! "${exit_code}" == "0" ] || [ -n "${debug}" ]
		then	export module_current oss_parameter dir_modules dir_conf config exit_code

			if [ -n "${aa}" ]
				then	name_current=$(echo "${sync_name_source[aa]}" | tr " " "-")
					export name_current
			fi

                        ${dir_modules}/do-debug -d create
			${dir_modules}/do-exit
			if [ ! "${?}" == "0" ]
				then	exit 1
			fi
			# unexport variables but not unset. If config is exported, own-snapshot will use list mode because it detects the config variable is set
			export -n module_current oss_parameter dir_modules dir_conf config exit_code
	fi
        unset module_current name_current
}

# hook for other configurations instead of a conf-file like a mysql database
if [ -n "${conf}" ]
	then	module_current=get-config
		. ${dir_modules}/${module_current}
		check-exit
fi


######################### VALIDITY CHECKS AND CREATING META-VARIABLES #########################

# these modules are in the same shell so check-exit does not catch the exit codes
module_current=check-config
. ${dir_modules}/${module_current}
#check-exit
module_current=set-config
. ${dir_modules}/${module_current}
#check-exit

# Backup the ifs
IFSBAK=${IFS}
export IFSBAK

# get-synclist can return spaces. so the ifs has to be by newline
IFS=$'\n'

# with synclist a list for syncnames can dynamically be created. At the moment this only works for absolute paths and not zfs with zfs list...
if [ -n "${sync_list}" ]
	then	module_current=get-synclist
		sync_name=($(${dir_modules}/${module_current}))
		check-exit
fi

IFS=${IFSBAK}

# sync_name_number has n-elements but the script starts with element 0. So the script has to count to n-1
if [ -n "${sync_name}" ] && [ ! -z "${sync_name}" ]
	then	sync_name_number=$((${#sync_name[@]} -1))
	else	echo "no sync_name is set. nothing to do" && exit 0
fi


######################### FIRST LOOP: SET SYNC-VARIABLES #########################

# set the control-variable for the first loop. This has to be -1 because arrays start at 0 and at the beginning of the loop aa is aa + 1
aa="-1"

while [ "${sync_name_number}" -gt "${aa}" ]
do	# control variable. will be used for the arrays
	aa_old=${aa}
	aa=$((${aa} + 1))

	# The script can use multiple vmids and newsyncnames, pre- and suffixes. These are synchronous to syncname. If the pre-/suffixes are empty it takes the last one set, an empty newsyncname will be replaced by syncname
	if [ -z "${sync_name_new[aa]}" ]
		then	sync_name_new[aa]=${sync_name[aa]}
	fi

	if [ ! -z "${sync_name_new_prefix[*]}" ]
		then	if [ -z "${sync_name_new_prefix[aa]}" ]
					then	sync_name_new_prefix[aa]=${sync_name_new_prefix[aa_old]}
			fi
	fi

	if [ ! -z "${sync_name_new_suffix[*]}" ]
		then	if [ -z "${sync_name_new_suffix[aa]}" ]
					then	sync_name_new_suffix[aa]=${sync_name_new_suffix[aa_old]}
			fi
	fi

	if [ "${mode_create}" == "kvm" ]
		then	if [ -z "${sync_vmid[aa]}" ]
					then	sync_vmid[aa]=${sync_vmid[aa_old]}
			fi
	fi

	##### define sync_name_source and sync_name_target #####

	if [ "${snap_rollback}" == "set" ] && [ "${mode_transfer}" == "zfs" ]
		then	sync_name_source[aa]=${sync_name_new_prefix[aa]}${sync_name_new[aa]}${sync_name_new_suffix[aa]}
			sync_name_target[aa]=${sync_name[aa]}
		else	sync_name_source[aa]=${sync_name[aa]}
			sync_name_target[aa]=${sync_name_new_prefix[aa]}${sync_name_new[aa]}${sync_name_new_suffix[aa]}
	fi
done
unset sync_name sync_name_new sync_name_new_prefix sync_name_new_suffix config_file_type


######################### SECOND LOOP: SET SNAP VARIABLES #########################

# set back the control-variable for the next loop
aa="-1"

# The previous checks looked for syntax erros. This verifies if the directories actually exist.
while [ "${sync_name_number}" -gt "${aa}" ]
do	aa=$((${aa} + 1))

	##### set global current variables #####
	sync_name_source_current=${sync_name_source[aa]}
	sync_name_target_current=${sync_name_target[aa]}
	export sync_name_source_current sync_name_target_current

	##### check the prerequisits on source side #####
	side_current=source
	config_server_current=${config_server_source}
	ssh_current=${ssh_source}
	dir_snap_current=${dir_snap_source}
	dir_root_current=${dir_root_source}
	dir_offset_current=${dir_offset_source}
	snap_list_current=${snap_list_source}
	snap_limit_current=${snap_limit_source}
	sync_name_current=${sync_name_source[aa]}
	sync_vmid_current=${sync_vmid[aa]}
	export side_current config_server_current ssh_current dir_snap_current dir_root_current dir_offset_current snap_list_current snap_limit_current sync_name_current sync_vmid_current

	##### checks on source side #####

	# check all ${mode_create}. atm this is only kvm
	if [ ! "${mode_create}" == "${mode_snapshot}" ]
		then	module_current=check-create
			${dir_modules}/${module_current}
			check-exit

			if [ "${mode_create}" == "mysql" ] || [ "${mode_create}" == "pgsql" ]
				then	config_sql_credentials[aa]=$(echo ${config_options_sql} | cut -d " " -f 1)
					config_sql_certificate[aa]=$(echo ${config_options_sql} | cut -d " " -f 2)
			fi
	fi

	# check all ${mode_snapshot}
	if [ -n "${mode_snapshot}" ]
		then	module_current=check-${mode_snapshot}
			snap_set_current=$(${dir_modules}/${module_current})
			check-exit
			snap_root_source[aa]=$(echo ${snap_set_current} | cut -d "~" -f 1)
			snap_set_source[aa]=$(echo ${snap_set_current} | cut -d "~" -f 2)
			if [ "${mode_snapshot}" == "file" ]
				then	snap_file_type[aa]=$(echo ${snap_set_current} | cut -d "~" -f 3)
					mode_override[aa]=$(echo ${snap_set_current} | cut -d "~" -f 4)
			fi
			unset snap_set_current
	fi

	# check all ${mode_transfer}. atm this is only rsync. if mode_file is file then rsync is assumed for mode_transfer and don't have to be checked extra
	if [ "${mode_transfer}" == "rsync" ]
		then	module_current=check-copy
			snap_rsync_source[aa]=$(${dir_modules}/${module_current})
			check-exit
	fi

	##### check the prerequisits on target side #####
	side_current=target
	config_server_current=${config_server_target}
	ssh_current=${ssh_target}
	dir_snap_current=${dir_snap_target}
	dir_root_current=${dir_root_target}
	dir_offset_current=${dir_offset_target}
	snap_list_current=${snap_list_target}
	snap_limit_current=${snap_limit_target}
	sync_name_current=${sync_name_target[aa]}
	export snap_set_current side_current config_server_current ssh_current dir_snap_current dir_root_current dir_offset_current snap_list_current snap_limit_current sync_name_current

	# basically not necessary on target side but left as a hook for future additions
	#if [ ! "${mode_create}" == "mode_snapshot" ]
	#	then	module_current=check-create
	#		${dir_modules}/${module_current}
	#		check-exit
	#fi

	if [ -n "${mode_snapshot}" ]
		then	module_current=check-${mode_snapshot}
			snap_set_current=$(${dir_modules}/${module_current})
			check-exit
			snap_root_target[aa]=$(echo ${snap_set_current} | cut -d "~" -f 1)
			snap_set_target[aa]=$(echo ${snap_set_current} | cut -d "~" -f 2)
			unset snap_set_current
	fi

	if [ "${mode_transfer}" == "rsync" ]
		then	module_current=check-copy
			snap_rsync_target[aa]=$(${dir_modules}/${module_current})
			check-exit
	fi

	########## output datasets ##########
	if [ "${show_datasets}" == "set" ]
		then	printf -- "\n--------------- ${sync_name_source[aa]} ---------------\n\n"
			echo "Sourcedataset is ${snap_set_source[aa]}"
			echo "Targetdataset is ${snap_set_target[aa]}"
			echo "Sourceroot is ${snap_root_source[aa]}"
			echo "Targetroot is ${snap_root_target[aa]}"
			echo "Sourcersync is ${snap_rsync_source[aa]}"
			echo "Targetrsync is ${snap_rsync_target[aa]}"
			echo "sync_name_source is ${sync_name_source[aa]}"
			echo "sync_name_target is ${sync_name_target[aa]}"
	fi

	unset snap_set_current side_current config_server_current ssh_current dir_snap_current dir_root_current dir_offset_current snap_list_current snap_limit_current sync_name_current
done

# if output = datasets the script ends here
if [ "${show_datasets}" == "set" ] && [ ! "${show_commands}" == "set" ]
	then exit 0
fi


######################### THIRD LOOP: SOURCE SNAPSHOTS #########################

if [ "${show_progress}" == "set" ]
	then	printf -- "\n\n--------------- Snapshots ---------------\n\n"
fi

if [ -n "${snap_list_source}" ]
	then	source ${dir_modules}/arg-osss
		module_current="own-snapshot"
		oss_parameter=${arg_oss_source}
		if [ "${snap_list_location_source}" == "ssh" ]
			then	ssh ${ssh_source} "own-snapshot ${arg_oss_source}"
			else	own-snapshot ${arg_oss_source}
		fi
		check-exit
		unset oss_parameter
fi

# set back the control-variable for the next loop
aa="-1"

# Loop snapshots
while [ "${sync_name_number}" -gt "${aa}" ]
do	aa=$((${aa} + 1))

	##### global #####
	snap_file_type_current=${snap_file_type[aa]}
	export snap_file_type_current

	##### source #####
	side_current=source
	config_server_current=${config_server_source}
	ssh_current=${ssh_source}
	snap_set_current=${snap_set_source[aa]}
	snap_root_current=${snap_root_source[aa]}
	export side_current config_server_current ssh_current snap_set_current snap_root_current

	if [ "${snap_limit_source}"  -ge 1 ]
		then	source ${dir_modules}/arg-osss
			module_current="own-snapshot"
			oss_parameter=${arg_oss_source}
			own-snapshot ${arg_oss_source}
			check-exit
			unset oss_parameter
	fi

	if [ -n "${mode_snapshot}" ]
		then	module_current=get-snapshots
			snap_shots_source[aa]=$(${dir_modules}/${module_current})
			check-exit
			snap_shots_source_ts[aa]=$(echo "${snap_shots_source[aa]}" | awk -F '~' '{ print $2 }')
			snap_shots_source[aa]=$(echo "${snap_shots_source[aa]}" | awk -F '~' '{ print $1 }')
			snap_number_source[aa]=$(echo "${snap_shots_source[aa]}" | sed '/^\s*$/d' | awk 'END{print NR}')
			snap_shots_strict_source[aa]=$(echo "${snap_shots_source[aa]}" | grep ${snap_name} || true)
			snap_number_strict_source[aa]=$(echo "${snap_shots_strict_source[aa]}" | sed '/^\s*$/d' | awk 'END{print NR}')
	fi

	##### target #####
	if [ -n "${mode_snapshot}" ]
		then	side_current=target
			config_server_current=${config_server_target}
			ssh_current=${ssh_target}
			snap_set_current=${snap_set_target[aa]}
			snap_root_current=${snap_root_target[aa]}
			export side_current config_server_current ssh_current snap_set_current snap_root_current

			module_current=get-snapshots
			snap_shots_target[aa]=$(${dir_modules}/${module_current})
			check-exit
			snap_shots_target_ts[aa]=$(echo "${snap_shots_target[aa]}" | awk -F '~' '{ print $2 }')
			snap_shots_target[aa]=$(echo "${snap_shots_target[aa]}" | awk -F '~' '{ print $1 }')
			snap_number_target[aa]=$(echo "${snap_shots_target[aa]}" | sed '/^\s*$/d' | awk 'END{print NR}')
			snap_shots_strict_target[aa]=$(echo "${snap_shots_target[aa]}" | grep ${snap_name} || true)
			snap_number_strict_target[aa]=$(echo "${snap_shots_strict_target[aa]}" | sed '/^\s*$/d' | awk 'END{print NR}')
	fi

	if [ "${show_snapshots}" == "set" ]
		then	printf -- "\n--------------- ${sync_name_source[aa]} ---------------\n\n"
			echo "-------------------------"
			printf "The Snapshotnumber for source is ${snap_number_source[aa]}:\n${snap_shots_source[aa]}\nThe Snapshotnumber for source with the name ${snap_name} is ${snap_number_strict_source[aa]}:\n${snap_shots_strict_source[aa]}\n"
			printf "The Snapshotnumber for for target is ${snap_number_target[aa]}:\n${snap_shots_target[aa]}\nThe Snapshotnumber for target with the name ${snap_name} is ${snap_number_strict_target[aa]}:\n${snap_shots_strict_target[aa]}\n"
			echo "-------------------------"
	fi

	unset snap_file_type_current side_current config_server_current ssh_current snap_set_current snap_root_current
done

# if output = datasets the script ends here
if [ "${show_snapshots}" == "set" ] && [ ! "${show_commands}" == "set" ]
	then exit 0
fi


######################### FOURTH LOOP: SYNC SOURCE AND TARGET #########################

if [ "${show_progress}" == "set" ]
	then	printf -- "\n\n--------------- Copy ---------------\n\n"
fi

# set back the control-variable for the next loop
aa="-1"

# Loop for actual copy, snapshots and log
while [ "${sync_name_number}" -gt "${aa}" ]
do	aa=$((${aa} + 1))

	if [ "${mode_transfer}" == "${mode_snapshot}" ] || [ "${mode_snapshot}" == "file" ] && [ "${snap_number_strict_source[aa]}" -ge "1" ] || [ -n "${log_dir}" ]
		then	# variables on source side
			snap_shots_source_current=${snap_shots_source[aa]}
			snap_number_source_current=${snap_number_source[aa]}
			export snap_shots_source_current snap_number_source_current

			# variables on target side
			snap_shots_target_current=${snap_shots_target[aa]}
			snap_number_target_current=${snap_number_target[aa]}
			snap_set_target_current=${snap_set_target[aa]}
			export snap_shots_target_current snap_number_target_current snap_set_target_current

			module_current=set-snapvars
			snap_new_source=$(${dir_modules}/${module_current})
			check-exit
			snap_common_source=$(echo ${snap_new_source} | cut -d "~" -f 1)
			snap_old_target=$(echo ${snap_new_source} | cut -d "~" -f 2)
			snap_exist_offset=$(echo ${snap_new_source} | cut -d "~" -f 3)
			snap_new_source=${snap_shots_strict_source[aa]##*$'\n'}
			export snap_new_source snap_common_source snap_old_target snap_exist_offset

			# when the snapshots are read, the snapshot on target wasn't created yet.
			#so a dummy has to be created in order to delete the right amount of snapshots and diff
			snap_shots_strict_target[aa]="${snap_shots_strict_target[aa]}"$'\n'"${snap_set_target_current}"${snap_string_separator}${snap_string}
			snap_number_strict_target[aa]=$((${snap_number_strict_target[aa]} + 1))
	fi

	if [ "${mode_transfer}" == "rsync" ]
		then	snap_rsync_source_current=${snap_rsync_source[aa]}
			snap_rsync_target_current=${snap_rsync_target[aa]}
			export snap_rsync_source_current snap_rsync_target_current
	fi

	if [ "${show_progress}" == "set" ]
		then	printf -- "\n--------------- ${sync_name_source[aa]} ---------------\n\n"
	fi

	if  [ "${show_snapvars}" == "set" ]
		then	printf "sourcesnapsnew is:\n${snap_new_source}\nsourcesnapsold is:\n${snap_common_source}\ntargetsnapsold is:\n${snap_old_target}\n"
			if [ ! "${show_commands}" == "set" ]
				then	# if only snapvars should be shown this loop ends here
					continue
			fi
	fi

	if [ ! "${snap_common_source}" == "newest" ] && [ ! "${show_snapvars}" == "set" ]
		then	if [ -n "${snap_multi}" ]
				then	snap_shots_source_ts_current=${snap_shots_source_ts[aa]}
					snap_shots_target_ts_current=${snap_shots_target_ts[aa]}
					export snap_exist_offset snap_shots_source_ts_current snap_shots_target_ts_current

					module_current=set-multisnap
					${dir_modules}/${module_current}
					check-exit

				elif [ "${mode_transfer}" == "zfs" ]
					then	module_current=copy-zfs
						${dir_modules}/${module_current}
						check-exit

				elif [ "${mode_transfer}" == "btrfs" ]
					then	module_current=copy-btrfs
						${dir_modules}/${module_current}
						check-exit

				elif [ "${mode_transfer}" == "rsync" ]
					then	module_current=copy-rsync
						${dir_modules}/${module_current}
						check-exit

						if [ "${snap_limit_target}" -gt 0 ] && [ ! "${mode_snapshot}" == "file" ]
							then	source ${dir_modules}/arg-osst
								module_current=own-snapshot
								oss_parameter=${arg_oss_target}
								own-snapshot ${arg_oss_target}
								check-exit
								unset oss_parameter
						fi
			fi
	fi

	if [ -n "${log_dir}" ]
		then	sync_name_source_current=${sync_name_source[aa]}
			snap_new_target=$(echo ${snap_shots_strict_target[aa]} | awk '{print $(NF)}')
			export sync_name_source_current snap_new_target
			module_current=do-log
			${dir_modules}/${module_current}
			check-exit
			unset sync_name_source_current snap_new_target
	fi

	unset snap_shots_source_current snap_number_source_current snap_shots_target_current snap_number_target_current snap_rsync_source_current snap_rsync_target_current snap_new_source snap_common_source snap_old_target snap_exist_offset
done

if [ -n "${snap_list_target}" ]
	then	source ${dir_modules}/arg-osst
		module_current=own-snapshot
		oss_parameter=${arg_oss_target}
		if [ "${snap_list_location_target}" == "ssh" ]
			then	ssh ${ssh_target} "own-snapshot ${arg_oss_target}"
			else	own-snapshot ${arg_oss_target}
		fi
		check-exit
		unset oss_parameter
fi

if [ "${show_snapvars}" == "set" ] && [ ! "${show_commands}" == "set" ]
	then	exit 0
fi


######################### FIFTH LOOP: CLEANUP SOURCE AND TARGET #########################

if [ "${snap_limit_source}"  -ge 1 ] || [ "${snap_limit_target}"  -ge 1 ]
	then	if [ "${show_progress}" == "set" ]
			then	printf -- "\n--------------- Delete Snapshots ---------------\n\n"
		fi

		aa="-1"

		while [ "${sync_name_number}" -gt "${aa}" ]
		do	aa=$((${aa} + 1))

			if [ "${snap_limit_source}" -gt 0 ]
				then	# variables on source side
					side_current=source
					config_server_current=${config_server_source}
					ssh_current=${ssh_source}
					snap_shots_current=${snap_shots_strict_source[aa]}
					snap_number_current=${snap_number_strict_source[aa]}
					snap_limit_current=${snap_limit_source}
					sync_vmid_current=${sync_vmid[aa]}
					export side_current config_server_current ssh_current snap_shots_current snap_number_current snap_limit_current sync_vmid_current

					module_current=do-snapdel
					${dir_modules}/${module_current}
					check-exit
					unset side_current config_server_current ssh_current snap_shots_current snap_number_current snap_limit_current sync_vmid_current
			fi

			if [ "${snap_limit_target}" -gt 0 ]
				then	# variables on target side
					side_current=target
					config_server_current=${config_server_target}
					ssh_current=${ssh_target}
					snap_shots_current=${snap_shots_strict_target[aa]}
					snap_number_current=${snap_number_strict_target[aa]}
					snap_limit_current=${snap_limit_target}
					export side_current config_server_current ssh_current snap_shots_current snap_number_current snap_limit_current

					module_current=do-snapdel
					${dir_modules}/${module_current}
					check-exit
					unset side_current config_server_current ssh_current snap_shots_current snap_number_current snap_limit_current
			fi
		done
fi
